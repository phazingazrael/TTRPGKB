/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/turndown/lib/turndown.browser.cjs.js
var require_turndown_browser_cjs = __commonJS({
  "node_modules/turndown/lib/turndown.browser.cjs.js"(exports, module2) {
    "use strict";
    function extend(destination) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key))
            destination[key] = source[key];
        }
      }
      return destination;
    }
    function repeat(character, count) {
      return Array(count + 1).join(character);
    }
    function trimLeadingNewlines(string) {
      return string.replace(/^\n*/, "");
    }
    function trimTrailingNewlines(string) {
      var indexEnd = string.length;
      while (indexEnd > 0 && string[indexEnd - 1] === "\n")
        indexEnd--;
      return string.substring(0, indexEnd);
    }
    var blockElements = [
      "ADDRESS",
      "ARTICLE",
      "ASIDE",
      "AUDIO",
      "BLOCKQUOTE",
      "BODY",
      "CANVAS",
      "CENTER",
      "DD",
      "DIR",
      "DIV",
      "DL",
      "DT",
      "FIELDSET",
      "FIGCAPTION",
      "FIGURE",
      "FOOTER",
      "FORM",
      "FRAMESET",
      "H1",
      "H2",
      "H3",
      "H4",
      "H5",
      "H6",
      "HEADER",
      "HGROUP",
      "HR",
      "HTML",
      "ISINDEX",
      "LI",
      "MAIN",
      "MENU",
      "NAV",
      "NOFRAMES",
      "NOSCRIPT",
      "OL",
      "OUTPUT",
      "P",
      "PRE",
      "SECTION",
      "TABLE",
      "TBODY",
      "TD",
      "TFOOT",
      "TH",
      "THEAD",
      "TR",
      "UL"
    ];
    function isBlock(node) {
      return is(node, blockElements);
    }
    var voidElements = [
      "AREA",
      "BASE",
      "BR",
      "COL",
      "COMMAND",
      "EMBED",
      "HR",
      "IMG",
      "INPUT",
      "KEYGEN",
      "LINK",
      "META",
      "PARAM",
      "SOURCE",
      "TRACK",
      "WBR"
    ];
    function isVoid(node) {
      return is(node, voidElements);
    }
    function hasVoid(node) {
      return has(node, voidElements);
    }
    var meaningfulWhenBlankElements = [
      "A",
      "TABLE",
      "THEAD",
      "TBODY",
      "TFOOT",
      "TH",
      "TD",
      "IFRAME",
      "SCRIPT",
      "AUDIO",
      "VIDEO"
    ];
    function isMeaningfulWhenBlank(node) {
      return is(node, meaningfulWhenBlankElements);
    }
    function hasMeaningfulWhenBlank(node) {
      return has(node, meaningfulWhenBlankElements);
    }
    function is(node, tagNames) {
      return tagNames.indexOf(node.nodeName) >= 0;
    }
    function has(node, tagNames) {
      return node.getElementsByTagName && tagNames.some(function(tagName) {
        return node.getElementsByTagName(tagName).length;
      });
    }
    var rules = {};
    rules.paragraph = {
      filter: "p",
      replacement: function(content) {
        return "\n\n" + content + "\n\n";
      }
    };
    rules.lineBreak = {
      filter: "br",
      replacement: function(content, node, options) {
        return options.br + "\n";
      }
    };
    rules.heading = {
      filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
      replacement: function(content, node, options) {
        var hLevel = Number(node.nodeName.charAt(1));
        if (options.headingStyle === "setext" && hLevel < 3) {
          var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
          return "\n\n" + content + "\n" + underline + "\n\n";
        } else {
          return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
        }
      }
    };
    rules.blockquote = {
      filter: "blockquote",
      replacement: function(content) {
        content = content.replace(/^\n+|\n+$/g, "");
        content = content.replace(/^/gm, "> ");
        return "\n\n" + content + "\n\n";
      }
    };
    rules.list = {
      filter: ["ul", "ol"],
      replacement: function(content, node) {
        var parent = node.parentNode;
        if (parent.nodeName === "LI" && parent.lastElementChild === node) {
          return "\n" + content;
        } else {
          return "\n\n" + content + "\n\n";
        }
      }
    };
    rules.listItem = {
      filter: "li",
      replacement: function(content, node, options) {
        content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
        var prefix = options.bulletListMarker + "   ";
        var parent = node.parentNode;
        if (parent.nodeName === "OL") {
          var start = parent.getAttribute("start");
          var index = Array.prototype.indexOf.call(parent.children, node);
          prefix = (start ? Number(start) + index : index + 1) + ".  ";
        }
        return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
      }
    };
    rules.indentedCodeBlock = {
      filter: function(node, options) {
        return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
      },
      replacement: function(content, node, options) {
        return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
      }
    };
    rules.fencedCodeBlock = {
      filter: function(node, options) {
        return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
      },
      replacement: function(content, node, options) {
        var className = node.firstChild.getAttribute("class") || "";
        var language = (className.match(/language-(\S+)/) || [null, ""])[1];
        var code = node.firstChild.textContent;
        var fenceChar = options.fence.charAt(0);
        var fenceSize = 3;
        var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
        var match;
        while (match = fenceInCodeRegex.exec(code)) {
          if (match[0].length >= fenceSize) {
            fenceSize = match[0].length + 1;
          }
        }
        var fence = repeat(fenceChar, fenceSize);
        return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
      }
    };
    rules.horizontalRule = {
      filter: "hr",
      replacement: function(content, node, options) {
        return "\n\n" + options.hr + "\n\n";
      }
    };
    rules.inlineLink = {
      filter: function(node, options) {
        return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
      },
      replacement: function(content, node) {
        var href = node.getAttribute("href");
        var title = cleanAttribute(node.getAttribute("title"));
        if (title)
          title = ' "' + title + '"';
        return "[" + content + "](" + href + title + ")";
      }
    };
    rules.referenceLink = {
      filter: function(node, options) {
        return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
      },
      replacement: function(content, node, options) {
        var href = node.getAttribute("href");
        var title = cleanAttribute(node.getAttribute("title"));
        if (title)
          title = ' "' + title + '"';
        var replacement;
        var reference;
        switch (options.linkReferenceStyle) {
          case "collapsed":
            replacement = "[" + content + "][]";
            reference = "[" + content + "]: " + href + title;
            break;
          case "shortcut":
            replacement = "[" + content + "]";
            reference = "[" + content + "]: " + href + title;
            break;
          default:
            var id = this.references.length + 1;
            replacement = "[" + content + "][" + id + "]";
            reference = "[" + id + "]: " + href + title;
        }
        this.references.push(reference);
        return replacement;
      },
      references: [],
      append: function(options) {
        var references = "";
        if (this.references.length) {
          references = "\n\n" + this.references.join("\n") + "\n\n";
          this.references = [];
        }
        return references;
      }
    };
    rules.emphasis = {
      filter: ["em", "i"],
      replacement: function(content, node, options) {
        if (!content.trim())
          return "";
        return options.emDelimiter + content + options.emDelimiter;
      }
    };
    rules.strong = {
      filter: ["strong", "b"],
      replacement: function(content, node, options) {
        if (!content.trim())
          return "";
        return options.strongDelimiter + content + options.strongDelimiter;
      }
    };
    rules.code = {
      filter: function(node) {
        var hasSiblings = node.previousSibling || node.nextSibling;
        var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
        return node.nodeName === "CODE" && !isCodeBlock;
      },
      replacement: function(content) {
        if (!content)
          return "";
        content = content.replace(/\r?\n|\r/g, " ");
        var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
        var delimiter = "`";
        var matches = content.match(/`+/gm) || [];
        while (matches.indexOf(delimiter) !== -1)
          delimiter = delimiter + "`";
        return delimiter + extraSpace + content + extraSpace + delimiter;
      }
    };
    rules.image = {
      filter: "img",
      replacement: function(content, node) {
        var alt = cleanAttribute(node.getAttribute("alt"));
        var src = node.getAttribute("src") || "";
        var title = cleanAttribute(node.getAttribute("title"));
        var titlePart = title ? ' "' + title + '"' : "";
        return src ? "![" + alt + "](" + src + titlePart + ")" : "";
      }
    };
    function cleanAttribute(attribute) {
      return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
    }
    function Rules(options) {
      this.options = options;
      this._keep = [];
      this._remove = [];
      this.blankRule = {
        replacement: options.blankReplacement
      };
      this.keepReplacement = options.keepReplacement;
      this.defaultRule = {
        replacement: options.defaultReplacement
      };
      this.array = [];
      for (var key in options.rules)
        this.array.push(options.rules[key]);
    }
    Rules.prototype = {
      add: function(key, rule) {
        this.array.unshift(rule);
      },
      keep: function(filter) {
        this._keep.unshift({
          filter,
          replacement: this.keepReplacement
        });
      },
      remove: function(filter) {
        this._remove.unshift({
          filter,
          replacement: function() {
            return "";
          }
        });
      },
      forNode: function(node) {
        if (node.isBlank)
          return this.blankRule;
        var rule;
        if (rule = findRule(this.array, node, this.options))
          return rule;
        if (rule = findRule(this._keep, node, this.options))
          return rule;
        if (rule = findRule(this._remove, node, this.options))
          return rule;
        return this.defaultRule;
      },
      forEach: function(fn) {
        for (var i = 0; i < this.array.length; i++)
          fn(this.array[i], i);
      }
    };
    function findRule(rules2, node, options) {
      for (var i = 0; i < rules2.length; i++) {
        var rule = rules2[i];
        if (filterValue(rule, node, options))
          return rule;
      }
      return void 0;
    }
    function filterValue(rule, node, options) {
      var filter = rule.filter;
      if (typeof filter === "string") {
        if (filter === node.nodeName.toLowerCase())
          return true;
      } else if (Array.isArray(filter)) {
        if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
          return true;
      } else if (typeof filter === "function") {
        if (filter.call(rule, node, options))
          return true;
      } else {
        throw new TypeError("`filter` needs to be a string, array, or function");
      }
    }
    function collapseWhitespace(options) {
      var element = options.element;
      var isBlock2 = options.isBlock;
      var isVoid2 = options.isVoid;
      var isPre = options.isPre || function(node2) {
        return node2.nodeName === "PRE";
      };
      if (!element.firstChild || isPre(element))
        return;
      var prevText = null;
      var keepLeadingWs = false;
      var prev = null;
      var node = next(prev, element, isPre);
      while (node !== element) {
        if (node.nodeType === 3 || node.nodeType === 4) {
          var text = node.data.replace(/[ \r\n\t]+/g, " ");
          if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
            text = text.substr(1);
          }
          if (!text) {
            node = remove(node);
            continue;
          }
          node.data = text;
          prevText = node;
        } else if (node.nodeType === 1) {
          if (isBlock2(node) || node.nodeName === "BR") {
            if (prevText) {
              prevText.data = prevText.data.replace(/ $/, "");
            }
            prevText = null;
            keepLeadingWs = false;
          } else if (isVoid2(node) || isPre(node)) {
            prevText = null;
            keepLeadingWs = true;
          } else if (prevText) {
            keepLeadingWs = false;
          }
        } else {
          node = remove(node);
          continue;
        }
        var nextNode = next(prev, node, isPre);
        prev = node;
        node = nextNode;
      }
      if (prevText) {
        prevText.data = prevText.data.replace(/ $/, "");
        if (!prevText.data) {
          remove(prevText);
        }
      }
    }
    function remove(node) {
      var next2 = node.nextSibling || node.parentNode;
      node.parentNode.removeChild(node);
      return next2;
    }
    function next(prev, current, isPre) {
      if (prev && prev.parentNode === current || isPre(current)) {
        return current.nextSibling || current.parentNode;
      }
      return current.firstChild || current.nextSibling || current.parentNode;
    }
    var root = typeof window !== "undefined" ? window : {};
    function canParseHTMLNatively() {
      var Parser = root.DOMParser;
      var canParse = false;
      try {
        if (new Parser().parseFromString("", "text/html")) {
          canParse = true;
        }
      } catch (e) {
      }
      return canParse;
    }
    function createHTMLParser() {
      var Parser = function() {
      };
      {
        if (shouldUseActiveX()) {
          Parser.prototype.parseFromString = function(string) {
            var doc = new window.ActiveXObject("htmlfile");
            doc.designMode = "on";
            doc.open();
            doc.write(string);
            doc.close();
            return doc;
          };
        } else {
          Parser.prototype.parseFromString = function(string) {
            var doc = document.implementation.createHTMLDocument("");
            doc.open();
            doc.write(string);
            doc.close();
            return doc;
          };
        }
      }
      return Parser;
    }
    function shouldUseActiveX() {
      var useActiveX = false;
      try {
        document.implementation.createHTMLDocument("").open();
      } catch (e) {
        if (window.ActiveXObject)
          useActiveX = true;
      }
      return useActiveX;
    }
    var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
    function RootNode(input, options) {
      var root2;
      if (typeof input === "string") {
        var doc = htmlParser().parseFromString(
          // DOM parsers arrange elements in the <head> and <body>.
          // Wrapping in a custom element ensures elements are reliably arranged in
          // a single element.
          '<x-turndown id="turndown-root">' + input + "</x-turndown>",
          "text/html"
        );
        root2 = doc.getElementById("turndown-root");
      } else {
        root2 = input.cloneNode(true);
      }
      collapseWhitespace({
        element: root2,
        isBlock,
        isVoid,
        isPre: options.preformattedCode ? isPreOrCode : null
      });
      return root2;
    }
    var _htmlParser;
    function htmlParser() {
      _htmlParser = _htmlParser || new HTMLParser();
      return _htmlParser;
    }
    function isPreOrCode(node) {
      return node.nodeName === "PRE" || node.nodeName === "CODE";
    }
    function Node(node, options) {
      node.isBlock = isBlock(node);
      node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
      node.isBlank = isBlank(node);
      node.flankingWhitespace = flankingWhitespace(node, options);
      return node;
    }
    function isBlank(node) {
      return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
    }
    function flankingWhitespace(node, options) {
      if (node.isBlock || options.preformattedCode && node.isCode) {
        return { leading: "", trailing: "" };
      }
      var edges = edgeWhitespace(node.textContent);
      if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
        edges.leading = edges.leadingNonAscii;
      }
      if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
        edges.trailing = edges.trailingNonAscii;
      }
      return { leading: edges.leading, trailing: edges.trailing };
    }
    function edgeWhitespace(string) {
      var m = string.match(/^(([ \t\r\n]*)(\s*))[\s\S]*?((\s*?)([ \t\r\n]*))$/);
      return {
        leading: m[1],
        // whole string for whitespace-only strings
        leadingAscii: m[2],
        leadingNonAscii: m[3],
        trailing: m[4],
        // empty for whitespace-only strings
        trailingNonAscii: m[5],
        trailingAscii: m[6]
      };
    }
    function isFlankedByWhitespace(side, node, options) {
      var sibling;
      var regExp;
      var isFlanked;
      if (side === "left") {
        sibling = node.previousSibling;
        regExp = / $/;
      } else {
        sibling = node.nextSibling;
        regExp = /^ /;
      }
      if (sibling) {
        if (sibling.nodeType === 3) {
          isFlanked = regExp.test(sibling.nodeValue);
        } else if (options.preformattedCode && sibling.nodeName === "CODE") {
          isFlanked = false;
        } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
          isFlanked = regExp.test(sibling.textContent);
        }
      }
      return isFlanked;
    }
    var reduce = Array.prototype.reduce;
    var escapes = [
      [/\\/g, "\\\\"],
      [/\*/g, "\\*"],
      [/^-/g, "\\-"],
      [/^\+ /g, "\\+ "],
      [/^(=+)/g, "\\$1"],
      [/^(#{1,6}) /g, "\\$1 "],
      [/`/g, "\\`"],
      [/^~~~/g, "\\~~~"],
      [/\[/g, "\\["],
      [/\]/g, "\\]"],
      [/^>/g, "\\>"],
      [/_/g, "\\_"],
      [/^(\d+)\. /g, "$1\\. "]
    ];
    function TurndownService2(options) {
      if (!(this instanceof TurndownService2))
        return new TurndownService2(options);
      var defaults = {
        rules,
        headingStyle: "setext",
        hr: "* * *",
        bulletListMarker: "*",
        codeBlockStyle: "indented",
        fence: "```",
        emDelimiter: "_",
        strongDelimiter: "**",
        linkStyle: "inlined",
        linkReferenceStyle: "full",
        br: "  ",
        preformattedCode: false,
        blankReplacement: function(content, node) {
          return node.isBlock ? "\n\n" : "";
        },
        keepReplacement: function(content, node) {
          return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
        },
        defaultReplacement: function(content, node) {
          return node.isBlock ? "\n\n" + content + "\n\n" : content;
        }
      };
      this.options = extend({}, defaults, options);
      this.rules = new Rules(this.options);
    }
    TurndownService2.prototype = {
      /**
       * The entry point for converting a string or DOM node to Markdown
       * @public
       * @param {String|HTMLElement} input The string or DOM node to convert
       * @returns A Markdown representation of the input
       * @type String
       */
      turndown: function(input) {
        if (!canConvert(input)) {
          throw new TypeError(
            input + " is not a string, or an element/document/fragment node."
          );
        }
        if (input === "")
          return "";
        var output = process.call(this, new RootNode(input, this.options));
        return postProcess.call(this, output);
      },
      /**
       * Add one or more plugins
       * @public
       * @param {Function|Array} plugin The plugin or array of plugins to add
       * @returns The Turndown instance for chaining
       * @type Object
       */
      use: function(plugin) {
        if (Array.isArray(plugin)) {
          for (var i = 0; i < plugin.length; i++)
            this.use(plugin[i]);
        } else if (typeof plugin === "function") {
          plugin(this);
        } else {
          throw new TypeError("plugin must be a Function or an Array of Functions");
        }
        return this;
      },
      /**
       * Adds a rule
       * @public
       * @param {String} key The unique key of the rule
       * @param {Object} rule The rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      addRule: function(key, rule) {
        this.rules.add(key, rule);
        return this;
      },
      /**
       * Keep a node (as HTML) that matches the filter
       * @public
       * @param {String|Array|Function} filter The unique key of the rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      keep: function(filter) {
        this.rules.keep(filter);
        return this;
      },
      /**
       * Remove a node that matches the filter
       * @public
       * @param {String|Array|Function} filter The unique key of the rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      remove: function(filter) {
        this.rules.remove(filter);
        return this;
      },
      /**
       * Escapes Markdown syntax
       * @public
       * @param {String} string The string to escape
       * @returns A string with Markdown syntax escaped
       * @type String
       */
      escape: function(string) {
        return escapes.reduce(function(accumulator, escape) {
          return accumulator.replace(escape[0], escape[1]);
        }, string);
      }
    };
    function process(parentNode) {
      var self = this;
      return reduce.call(parentNode.childNodes, function(output, node) {
        node = new Node(node, self.options);
        var replacement = "";
        if (node.nodeType === 3) {
          replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
        } else if (node.nodeType === 1) {
          replacement = replacementForNode.call(self, node);
        }
        return join(output, replacement);
      }, "");
    }
    function postProcess(output) {
      var self = this;
      this.rules.forEach(function(rule) {
        if (typeof rule.append === "function") {
          output = join(output, rule.append(self.options));
        }
      });
      return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
    }
    function replacementForNode(node) {
      var rule = this.rules.forNode(node);
      var content = process.call(this, node);
      var whitespace = node.flankingWhitespace;
      if (whitespace.leading || whitespace.trailing)
        content = content.trim();
      return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
    }
    function join(output, replacement) {
      var s1 = trimTrailingNewlines(output);
      var s2 = trimLeadingNewlines(replacement);
      var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
      var separator = "\n\n".substring(0, nls);
      return s1 + separator + s2;
    }
    function canConvert(input) {
      return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
    }
    module2.exports = TurndownService2;
  }
});

// node_modules/turndown-plugin-gfm/lib/turndown-plugin-gfm.cjs.js
var require_turndown_plugin_gfm_cjs = __commonJS({
  "node_modules/turndown-plugin-gfm/lib/turndown-plugin-gfm.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var highlightRegExp = /highlight-(?:text|source)-([a-z0-9]+)/;
    function highlightedCodeBlock(turndownService) {
      turndownService.addRule("highlightedCodeBlock", {
        filter: function(node) {
          var firstChild = node.firstChild;
          return node.nodeName === "DIV" && highlightRegExp.test(node.className) && firstChild && firstChild.nodeName === "PRE";
        },
        replacement: function(content, node, options) {
          var className = node.className || "";
          var language = (className.match(highlightRegExp) || [null, ""])[1];
          return "\n\n" + options.fence + language + "\n" + node.firstChild.textContent + "\n" + options.fence + "\n\n";
        }
      });
    }
    function strikethrough(turndownService) {
      turndownService.addRule("strikethrough", {
        filter: ["del", "s", "strike"],
        replacement: function(content) {
          return "~" + content + "~";
        }
      });
    }
    var indexOf = Array.prototype.indexOf;
    var every = Array.prototype.every;
    var rules = {};
    rules.tableCell = {
      filter: ["th", "td"],
      replacement: function(content, node) {
        return cell(content, node);
      }
    };
    rules.tableRow = {
      filter: "tr",
      replacement: function(content, node) {
        var borderCells = "";
        var alignMap = { left: ":--", right: "--:", center: ":-:" };
        if (isHeadingRow(node)) {
          for (var i = 0; i < node.childNodes.length; i++) {
            var border = "---";
            var align = (node.childNodes[i].getAttribute("align") || "").toLowerCase();
            if (align)
              border = alignMap[align] || border;
            borderCells += cell(border, node.childNodes[i]);
          }
        }
        return "\n" + content + (borderCells ? "\n" + borderCells : "");
      }
    };
    rules.table = {
      // Only convert tables with a heading row.
      // Tables with no heading row are kept using `keep` (see below).
      filter: function(node) {
        return node.nodeName === "TABLE" && isHeadingRow(node.rows[0]);
      },
      replacement: function(content) {
        content = content.replace("\n\n", "\n");
        return "\n\n" + content + "\n\n";
      }
    };
    rules.tableSection = {
      filter: ["thead", "tbody", "tfoot"],
      replacement: function(content) {
        return content;
      }
    };
    function isHeadingRow(tr) {
      var parentNode = tr.parentNode;
      return parentNode.nodeName === "THEAD" || parentNode.firstChild === tr && (parentNode.nodeName === "TABLE" || isFirstTbody(parentNode)) && every.call(tr.childNodes, function(n) {
        return n.nodeName === "TH";
      });
    }
    function isFirstTbody(element) {
      var previousSibling = element.previousSibling;
      return element.nodeName === "TBODY" && (!previousSibling || previousSibling.nodeName === "THEAD" && /^\s*$/i.test(previousSibling.textContent));
    }
    function cell(content, node) {
      var index = indexOf.call(node.parentNode.childNodes, node);
      var prefix = " ";
      if (index === 0)
        prefix = "| ";
      return prefix + content + " |";
    }
    function tables(turndownService) {
      turndownService.keep(function(node) {
        return node.nodeName === "TABLE" && !isHeadingRow(node.rows[0]);
      });
      for (var key in rules)
        turndownService.addRule(key, rules[key]);
    }
    function taskListItems(turndownService) {
      turndownService.addRule("taskListItems", {
        filter: function(node) {
          return node.type === "checkbox" && node.parentNode.nodeName === "LI";
        },
        replacement: function(content, node) {
          return (node.checked ? "[x]" : "[ ]") + " ";
        }
      });
    }
    function gfm(turndownService) {
      turndownService.use([
        highlightedCodeBlock,
        strikethrough,
        tables,
        taskListItems
      ]);
    }
    exports.gfm = gfm;
    exports.highlightedCodeBlock = highlightedCodeBlock;
    exports.strikethrough = strikethrough;
    exports.tables = tables;
    exports.taskListItems = taskListItems;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImportFoundry
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs/promises"));
var TurndownService = require_turndown_browser_cjs();
var turndownPluginGfm = require_turndown_plugin_gfm_cjs();
var GS_OBSIDIAN_FOLDER = "assetsLocation";
var GS_FOLDER_NOTES = "createFolderNotes";
var GS_SHOW_RIBBON = "showRibbon";
var FRONTMATTER = "---\n";
var DEFAULT_SETTINGS = {
  [GS_OBSIDIAN_FOLDER]: "FoundryImport",
  [GS_FOLDER_NOTES]: false,
  [GS_SHOW_RIBBON]: true
};
var ImportFoundry = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    if (this.settings[GS_SHOW_RIBBON]) {
      this.createRibbon();
    }
    this.addCommand({
      id: "import-foundry",
      name: "Import Foundry journal.db",
      callback: () => {
        const modal = new FileSelectorModal(this.app);
        modal.setHandler(this, this.readJournalEntries, this.settings[GS_OBSIDIAN_FOLDER], this.settings[GS_FOLDER_NOTES]);
        modal.open();
      }
    });
    this.addSettingTab(new FoundryImportSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  createRibbon() {
    this.ribbonIconEl = this.addRibbonIcon("magnifying-glass", "Import Foundry", async (evt) => {
      const modal = new FileSelectorModal(this.app);
      modal.setHandler(this, this.readJournalEntries, this.settings[GS_OBSIDIAN_FOLDER], this.settings[GS_FOLDER_NOTES]);
      modal.open();
    });
    this.ribbonIconEl.addClass("import-foundry-ribbon-class");
  }
  destroyRibbon() {
    this.ribbonIconEl.remove();
  }
  validFilename(name) {
    const regexp = /[<>:"/\\|?*]/g;
    return name.replaceAll(regexp, "_");
  }
  async readDB(dbfile) {
    let contents = typeof dbfile == "string" ? await fs.readFile(
      dbfile,
      /*options*/
      { encoding: "utf-8" }
    ).catch((err) => console.error(`Failed to read file ${dbfile} due to ${err}`)) : await dbfile.text().catch((err) => console.error(`Failed to read file ${dbfile} due to ${err}`));
    if (!contents)
      return void 0;
    let result = [];
    for (const line of contents.split("\n")) {
      if (line.length == 0 || line.contains('"$$deleted":true'))
        continue;
      result.push(JSON.parse(line));
    }
    return result;
  }
  convertHtml(html) {
    if (!this.turndownService) {
      this.turndownService = new TurndownService({ headingStyle: "atx" });
      this.gfm = turndownPluginGfm.gfm;
      this.turndownService.use(this.gfm);
    }
    let markdown;
    try {
      markdown = this.turndownService.turndown(html);
    } catch (error) {
      console.warn(`Error: failed to decode html:`, html);
    }
    return markdown;
  }
  async readJournalEntries(file, topfoldername, createFolderNotes) {
    async function deleteIfExists(app, filename) {
      let exist = app.vault.getAbstractFileByPath(filename);
      if (exist) {
        console.debug(`Deleting existing folder ${filename}`);
        await app.vault.delete(exist).catch((err) => console.log(`Failed to delete ${filename} due to ${err}`));
      }
    }
    let sourcepath = file.path;
    console.log(`Reading file ${sourcepath}, length ${file.size}`);
    if (file.size == 0) {
      new import_obsidian.Notice(`File ${sourcepath} is empty`);
      return;
    }
    let mynotice = new import_obsidian.Notice(`Starting import`, 0);
    this.create_folder_notes = createFolderNotes;
    await this.app.vault.createFolder(topfoldername).catch((err) => console.log(`Destination '${topfoldername}' already exists`));
    let folderdb = await this.readDB(sourcepath.replace("journal.db", "folders.db"));
    let journaldb = await this.readDB(file);
    if (!journaldb)
      return;
    mynotice.setMessage("Reading Foundry folders");
    let folders = /* @__PURE__ */ new Map();
    for (let folder of folderdb) {
      if (folder.type != "JournalEntry")
        continue;
      folders.set(folder._id, {
        name: folder.name,
        parent: folder.folder,
        // Foundry._id
        filename: this.validFilename(folder.name),
        fullpath: ""
      });
    }
    mynotice.setMessage("Getting Foundry V10 folder for each journal");
    for (let journal of journaldb) {
      if (journal.pages?.length > 1) {
        folders.set(journal._id, {
          name: journal.name,
          parent: journal.folder,
          // Foundry._id
          filename: this.validFilename(journal.name),
          fullpath: ""
        });
      }
    }
    mynotice.setMessage(`Creating ${folders.size} folders in Obsidian vault`);
    for (let folder of folders.values()) {
      let fullpath = folder.filename;
      let parentid = folder.parent;
      while (parentid) {
        let parentobj = folders.get(parentid);
        if (!parentobj)
          break;
        fullpath = parentobj.filename + "/" + fullpath;
        parentid = parentobj.parent;
      }
      fullpath = topfoldername + "/" + fullpath;
      await this.app.vault.createFolder(fullpath).catch((err) => {
        if (err.message != "Folder already exists.")
          console.error(`Failed to create folder: '${fullpath}' due to ${err}`);
      });
      folder.fullpath = fullpath + "/";
      if (this.create_folder_notes) {
        let notepath = folder.fullpath + folder.filename + ".md";
        await deleteIfExists(this.app, notepath);
        let foldernote = FRONTMATTER + `title: "${folder.name}"
aliases: "${folder.name}"
` + FRONTMATTER + `# ${folder.name}
`;
        console.debug(`Creating folder Note for '${folder.name}' in '${notepath}'`);
        await this.app.vault.create(notepath, foldernote);
      }
    }
    let entries = [];
    const idmap = /* @__PURE__ */ new Map();
    mynotice.setMessage(`Reading ${journaldb.length} Foundry journals`);
    for (let journal of journaldb) {
      if (journal.pages) {
        let onepage = journal.pages.length === 1;
        if (!onepage) {
          let markdown = "## Table of Contents\n";
          for (let page of journal.pages) {
            markdown += `
- [[${this.validFilename(page.name)}]]`;
          }
          entries.push({
            _id: journal._id,
            filename: this.validFilename(journal.name),
            parent: journal._id,
            // This is a Folder note, so goes INSIDE the folder for this journal entry
            markdown: FRONTMATTER + `title: "${journal.name}"
aliases: "${journal.name}"
foundryId: journal-${journal._id}
` + FRONTMATTER + markdown
          });
        }
        idmap.set(journal._id, this.validFilename(journal.name));
        for (let page of journal.pages) {
          let markdown;
          let pagename = onepage ? journal.name : page.name;
          switch (page.type) {
            case "text":
              switch (page.text.format) {
                case 1:
                  if (page.text.content) {
                    try {
                      markdown = this.convertHtml(page.text.content);
                    } catch (err) {
                      console.error(`Turndown failed to convert HTML to Markdown:
${err.message}
${journal.content}`);
                      mynotice.setMessage(`Error during import of ${journal.name}`);
                    }
                  }
                  break;
                case 2:
                  markdown = page.text.markdown;
                  break;
              }
              break;
            case "image":
            case "pdf":
            case "video":
              if (page.src)
                markdown = `![](${page.src})`;
              break;
          }
          let pageid = journal._id + ".JournalEntryPage." + page._id;
          markdown = FRONTMATTER + `title: "${pagename}"
aliases: "${pagename}"
foundryId: journal-${pageid}
` + FRONTMATTER + (markdown || "");
          let filename = this.validFilename(pagename);
          entries.push({
            _id: pageid,
            filename,
            parent: onepage ? journal.folder : journal._id,
            // parent folder = the Journal main page
            markdown
          });
          idmap.set(pageid, filename);
        }
      } else {
        let markdown;
        if (journal.content) {
          try {
            markdown = this.convertHtml(journal.content);
          } catch (err) {
            console.error(`Turndown failed to convert HTML to Markdown:
${err.message}
${journal.content}`);
            mynotice.setMessage(`Error during import of ${journal.name}`);
          }
        }
        markdown = FRONTMATTER + `title: "${journal.name}"
aliases: "${journal.name}"
foundryId: journal-${journal._id}
` + FRONTMATTER + (markdown || "");
        const filename = this.validFilename(journal.name);
        entries.push({
          _id: journal._id,
          filename,
          parent: journal.folder,
          markdown
        });
        idmap.set(journal._id, filename);
      }
    }
    function convert(str, id, label) {
      let section = id.indexOf("#");
      if (section > 0)
        id = id.slice(0, section);
      let filename = idmap.get(id);
      if (label == filename)
        return `[[${filename}]]`;
      else
        return `[[${filename}|${label}]]`;
    }
    let foundryuserdata = sourcepath.slice(0, sourcepath.indexOf("worlds\\"));
    let filestomove = [];
    let destForImages = topfoldername + "/zz_asset-files";
    let currententry;
    function fileconvert(str, filename) {
      if (filename.startsWith("data:image") || filename.contains(":")) {
        console.log(`Ignoring image file/external URL in '${currententry}':
${filename}`);
        return str;
      }
      filename = decodeURIComponent(filename);
      let basefilename = filename.slice(filename.lastIndexOf("/") + 1);
      filestomove.push({
        srcfile: foundryuserdata + filename,
        dstfile: destForImages + "/" + basefilename,
        entryName: currententry
      });
      return `![[${basefilename}]]`;
    }
    mynotice.setMessage(`Replacing links in ${entries.length} new entries`);
    for (let item of entries) {
      if (item.markdown.includes("@JournalEntry")) {
        const pattern1 = /@JournalEntry\\\[([^\]]*)\\\]{([^\}]*)}/g;
        item.markdown = item.markdown.replaceAll(pattern1, convert);
        const pattern2 = /@JournalEntry\[([^\]]*)\]{([^\}]*)}/g;
        item.markdown = item.markdown.replaceAll(pattern2, convert);
      }
      if (item.markdown.includes("@UUID\\[JournalEntry.")) {
        const pattern = /@UUID\\\[JournalEntry\.([^\]]*)\\\]{([^\}]*)}/g;
        item.markdown = item.markdown.replaceAll(pattern, convert);
      }
      if (item.markdown.includes("@UUID[JournalEntry.")) {
        const pattern = /@UUID\[JournalEntry\.([^\]]*)\]{([^\}]*)}/g;
        item.markdown = item.markdown.replaceAll(pattern, convert);
      }
      if (item.markdown.includes("![](")) {
        const filepattern = /!\[\]\(([^)]*)\)/g;
        currententry = item.filename;
        item.markdown = item.markdown.replaceAll(filepattern, fileconvert);
      }
    }
    if (filestomove.length > 0) {
      await this.app.vault.createFolder(destForImages).catch((err) => console.log(`Destination '${destForImages}' already exists`));
    }
    this.settings[GS_OBSIDIAN_FOLDER] = topfoldername;
    this.settings[GS_FOLDER_NOTES] = createFolderNotes;
    this.saveSettings();
    mynotice.setMessage("Transferring image/binary files");
    for (let item of filestomove) {
      let body = await fs.readFile(item.srcfile).catch((err) => {
        console.error(`Failed to read ${item.srcfile} from '${item.entryName}' due to ${err}`);
        return null;
      });
      if (body) {
        await deleteIfExists(this.app, item.dstfile);
        await this.app.vault.createBinary(item.dstfile, body).catch((err) => console.error(`Failed to create asset file ${item.dstfile} due to ${err}`));
      }
    }
    mynotice.setMessage(`Creating $[entries.length} Obsidian Notes`);
    for (const item of entries) {
      if (item.parent && !folders.has(item.parent))
        console.warn(`Journal '${item.filename}' has invalid Parent '${item.parent}'`);
      let path = folders.get(item.parent)?.fullpath || topfoldername + "/";
      let outfilename = path + item.filename + ".md";
      await deleteIfExists(this.app, outfilename);
      mynotice.setMessage(`Importing
${item.filename}`);
      await this.app.vault.create(outfilename, item.markdown).catch((err) => new import_obsidian.Notice(`Creating Note for ${item.filename} failed due to ${err}`));
    }
    mynotice.setMessage("Import Finished");
  }
};
var FileSelectorModal = class extends import_obsidian.Modal {
  setHandler(caller, handler, foldername, createFolderNote) {
    this.caller = caller;
    this.handler = handler;
    this.foldername = foldername;
    this.createFolderNote = createFolderNote;
  }
  onOpen() {
    const setting1 = new import_obsidian.Setting(this.contentEl).setName("Choose File").setDesc("Choose journal.db file to import");
    const input1 = setting1.controlEl.createEl("input", {
      attr: {
        type: "file",
        accept: ".db"
      }
    });
    const setting2 = new import_obsidian.Setting(this.contentEl).setName("Parent Folder").setDesc("Enter the name of the Obsidian folder into which the data will be imported");
    const input2 = setting2.controlEl.createEl("input", {
      attr: {
        type: "string"
      }
    });
    input2.value = this.foldername;
    const setting3 = new import_obsidian.Setting(this.contentEl).setName("Create Folder Notes").setDesc("When checked, a note with the same name as the folder will be created in each folder (e.g. for AidenLX's Folder Notes plugin)");
    const input3 = setting3.controlEl.createEl("input", {
      attr: {
        type: "checkbox"
      }
    });
    input3.checked = this.createFolderNote;
    const setting4 = new import_obsidian.Setting(this.contentEl).setName("Process").setDesc("Click this button to start the import");
    const input4 = setting4.controlEl.createEl("button");
    input4.textContent = "IMPORT";
    input4.onclick = async () => {
      const { files } = input1;
      if (!files.length)
        return;
      for (let i = 0; i < files.length; i++) {
        await this.handler.call(this.caller, files[i], input2.value, input3.checked);
      }
      this.close();
    };
  }
};
var FoundryImportSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Foundry Import." });
    new import_obsidian.Setting(containerEl).setName("Show ribbon").setDesc("When selected, shows the magnifying glass in the left ribbon bar to import foundry journal.db files").addToggle((text) => text.setValue(this.plugin.settings[GS_SHOW_RIBBON]).onChange(async (value) => {
      this.plugin.settings[GS_SHOW_RIBBON] = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.createRibbon();
      } else {
        this.plugin.destroyRibbon();
      }
    }));
  }
};
